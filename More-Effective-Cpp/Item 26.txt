// Item 26: Limiting the number of objects of a class.
// Example: Printer class.

// ***********************************************************************************
// Concept 1: Allowing 0 objects.
// Idea: To prevent a class from being instantiated, declare its constructors private.
// ***********************************************************************************

class CantBeInstantiated
{
private:
	CantBeInstantiated();
	CantBeInstantiated(const CantBeInstantiated&);
}

// *********************************************************************
// Concept 2: Allowing 1 object.
// Idea: Encapsulate unique instance so that everybody has access to it.
// *********************************************************************

// Option A: Declare the constructors private and encapsulate the unique instance inside a friend function.
//           - Private constructors suppress object creation.
//           - Global function thePrinter is declared a friend function of the class, which allows it to access the constructors.
//           - thePrinter contains a static printer object, which means that we only have 1 instance of the class.

class PrintJob; // Forward declaration.

class Printer
{
public:
	void submitJob(const PrintJob& job);
	void reset();
	void performSelfTest();
	...
	friend Printer& thePrinter();
	
private:
	Printer();
	Printer(const Printer& rhs);
	...
};

Printer& thePrinter()
{
	static Printer p; // Unique instance
	return p;
}

// Using thePrinter looks like this with option A:

class PrintJob
{
public:
	PrintJob(const string& whatToPrint);
	...
};

thePrinter().reset();
thePrinter().submitJob("Hello world!"); // This call implicitly creates a PrintJob object.

// Option B: Declare the constructors private and encapsulate the unique instance inside a public static member function.
//           - You can do this if you don't like the global function used in option A.

class Printer
{
public:
	static Printer& thePrinter();
	...

private:
	Printer();
	Printer(const Printer& rhs);
	...
};

Printer& Printer::thePrinter()
{
	static Printer p;
	return p;
}

// Using thePrinter looks like this with option B:

Printer::thePrinter().reset();
Printer::thePrinter().submitJob("Hello world!"); // This call implicitly creates a PrintJob object.

// Option C: Declare the constructors private and encapsulate the unique instance inside a friend function that belongs to the same namespace as the class.
//           - You can do this if you don't like the global function used in option A.

namespace PrintingStuff
{
	class Printer
	{
	public:
		void submitJob(const PrintJob& job);
		void reset();
		void performSelfTest();
		...
		friend Printer& thePrinter();
	
	private:
		Printer();
		Printer(const Printer& rhs);
		...
	};

	Printer& thePrinter()
	{
		static Printer p; // Unique instance
		return p;
	}
}

// Using thePrinter looks like this with option C:

PrintingStuff::thePrinter().reset();
PrintingStuff::thePrinter().submitJob("Hello world!"); // This call implicitly creates a PrintJob object.

// Notes on options A, B and C:
// The unique printer object must be static inside a function instead of a class.
// A static object inside of a class is always constructed.
// A static object inside of a function is constructed the first time through the function. If the function is never called, it is never created.
// We know when a function static is initialized, but we don't know when a class static/global static is initialized.
// C++ says nothing about the initialization order of static objects in different translation units.

// *********************************************************************
// Concept 3: Counting the number of objects in existence.
// Idea: Encapsulate unique instance so that everybody has access to it.
// *********************************************************************

class Printer
{
public:
	class TooManyObjects{};
	
	Printer();
	~Printer();
	
private:
	static size_t numObjects;
	Printer(const Printer& rhs); // Copying is not allowed because we limit the number of instances of the class to 1.
};

size_t Printer::numObjects = 0; // Obligatory definition of class static

Printer::Printer()
{
	if (numObjects >= 1)
	{
		throw TooManyObjects;
	}
	
	// Proceed with normal construction
	
	++numObjects;
}

Printer::~Printer()
{
	// Proceed with normal destruction
	
	--numObjects;
}

// ****************************************************************************************************************
// Concept 4: Counting the number of objects in existence while limiting the contexts in which they can be created.
// Idea: Only allow objects to exist on their own, and limit those kinds of instantiations.
// ****************************************************************************************************************

// Problems with concept 3:
// Printer objects can exist in 3 different contexts:
// 1) On their own.
// 2) As base class parts of more derived objects.
// 3) Embedded inside larger objects.

// So, what does it mean to keep track of the number of objects in existence?
// Often, you will want to only allow objects to exist on their own, and you will want to limit those kinds of instantiations.

// Classes with private constructors can't be used as base classes, nor can they be embedded inside other objects.
// So, to prevent derivation you can declare constructors private and use pseudo-constructors:

class FSA
{
public:
	static FSA * makeFSA();
	static FSA * makeFSA(const FSA& rhs);
	~FSA();
	...
private:
	FSA();
	FSA(const FSA& rhs);
};

FSA * FSA::makeFSA()
{
	return new FSA();
}

FSA * FSA::makeFSA(const FSA& rhs)
{
	return new FSA(rhs);
}

// Clients must call delete unless they use smart pointers

std::unique_ptr<FSA> pFiniteStateAgent1(FSA::makeFSA());
std::unique_ptr<FSA> pFiniteStateAgent2(FSA::makeFSA(*pFiniteStateAgent1));

// ************************************************************************************************************
// Concept 5: Only allow a single instance to exist at a time, but allow instances to be created and destroyed.
// Idea: Combine object-counting with pseudo-constructors to limit the number of instances of a class
//       while allowing clients to construct/destruct them.
// ************************************************************************************************************